"""Arch Linux package builder."""

import shutil
import subprocess
import time
from pathlib import Path
from typing import Optional

from deb2arch.exceptions import BuildError
from deb2arch.models import ArchPackageInfo


class ArchBuilder:
    """Builds Arch Linux packages."""

    def __init__(self):
        """Initialize the builder."""
        self.bsdtar = shutil.which("bsdtar")
        self.fakeroot = shutil.which("fakeroot")

        if not self.bsdtar:
            raise BuildError("bsdtar is required but not found")
        if not self.fakeroot:
            raise BuildError("fakeroot is required but not found")

    def build_package(
        self,
        info: ArchPackageInfo,
        content_dir: Path,
        output_dir: Path,
        install_script: Optional[str] = None,
    ) -> Path:
        """Build an Arch Linux package.

        Args:
            info: Package metadata.
            content_dir: Directory containing the unpacked package roots (pkg directory).
            output_dir: Directory where the final package will be saved.
            install_script: Optional content of the .install script.

        Returns:
            Path to the created package file.
        """
        package_name = f"{info.pkgname}-{info.pkgver}-{info.pkgrel}-{info.arch}.pkg.tar.zst"
        package_path = output_dir / package_name

        # Prepare the package directory
        # We need to ensure directory structure is Arch-compliant (usr move)
        self._fix_directory_structure(content_dir)

        # Write .PKGINFO
        self._write_pkginfo(info, content_dir / ".PKGINFO")

        # Write .install file if provided
        if install_script:
            (content_dir / ".INSTALL").write_text(install_script)

        # Generate .MTREE
        self._generate_mtree(content_dir)

        # Create the package archive
        self._create_archive(content_dir, package_path)

        return package_path

    def _fix_directory_structure(self, content_dir: Path) -> None:
        """Fix directory structure to match Arch standards (usr move)."""
        # Move /bin, /sbin, /lib to /usr/...
        
        for d in ["bin", "sbin", "lib", "lib64"]:
            src = content_dir / d
            if src.exists():
                dst = content_dir / "usr" / ("bin" if d in ["bin", "sbin"] else "lib")
                self._move_contents(src, dst)
                shutil.rmtree(src)

    def _move_contents(self, src: Path, dst: Path) -> None:
        """Move contents of src directory to dst directory, creating dst if needed."""
        dst.mkdir(parents=True, exist_ok=True)
        for item in src.iterdir():
            target = dst / item.name
            if target.exists() and item.is_dir() and target.is_dir():
                self._move_contents(item, target)
                shutil.rmtree(item)
            elif target.exists():
                # Overwrite
                if target.is_dir():
                    shutil.rmtree(target)
                elif item.is_dir():
                    shutil.rmtree(target)
                else:
                    target.unlink()
                shutil.move(str(item), str(target))
            else:
                shutil.move(str(item), str(target))

    def _write_pkginfo(self, info: ArchPackageInfo, path: Path) -> None:
        """Write the .PKGINFO file."""
        lines = [
            f"# Generated by deb2arch",
            f"pkgname = {info.pkgname}",
            f"pkgver = {info.pkgver}-{info.pkgrel}",
            f"pkgdesc = {info.pkgdesc}",
            f"url = {info.url or ''}",
            f"builddate = {info.builddate or int(time.time())}",
            f"packager = {info.packager}",
            f"size = {info.size}",
            f"arch = {info.arch}",
        ]
        
        for lic in info.license:
            lines.append(f"license = {lic}")
        for dep in info.depends:
            lines.append(f"depend = {dep}")
        for opt in info.optdepends:
            lines.append(f"optdepend = {opt}")
        for conf in info.conflicts:
            lines.append(f"conflict = {conf}")
        for prov in info.provides:
            lines.append(f"provides = {prov}")
        for repl in info.replaces:
            lines.append(f"replaces = {repl}")
        for bkp in info.backup:
            lines.append(f"backup = {bkp}")

        path.write_text("\n".join(lines) + "\n")

    def _generate_mtree(self, content_dir: Path) -> None:
        """Generate .MTREE file using bsdtar."""
        cmd = [
            self.fakeroot,
            self.bsdtar,
            "-c",
            "--format=mtree",
            "--options=!all,use-set,type,uid,gid,mode,time,size,md5,sha256,link",
            "-f", ".MTREE",
            "."
        ]
        
        try:
            subprocess.run(
                cmd,
                cwd=content_dir,
                check=True,
                capture_output=True,
                text=True
            )
            
            mtree_path = content_dir / ".MTREE"
            if mtree_path.exists():
                subprocess.run(["gzip", "-n", str(mtree_path)], check=True)
                # gzip output is .MTREE.gz
                shutil.move(str(mtree_path) + ".gz", str(mtree_path))
                
        except subprocess.CalledProcessError as e:
            raise BuildError(f"Failed to generate .MTREE: {e.stderr}")

    def _create_archive(self, content_dir: Path, output_file: Path) -> None:
        """Create the final .pkg.tar.zst archive."""
        cmd = [
            self.fakeroot,
            self.bsdtar,
            "--zstd",
            "-cf",
            str(output_file.absolute()),
            "."
        ]
        
        try:
            subprocess.run(
                cmd,
                cwd=content_dir,
                check=True,
                capture_output=True,
                text=True
            )
        except subprocess.CalledProcessError as e:
            raise BuildError(f"Failed to create package archive: {e.stderr}")
